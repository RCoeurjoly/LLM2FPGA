* Table comparison

| Project      | link                                       | stars | commits | last updated | Snapshot date    |
|--------------+--------------------------------------------+-------+---------+--------------+------------------|
| deepwok/mase | https://github.com/deepwok/mase            |   183 |     541 | 7 months ago | <2025-11-12 Wed> |
| TMMA         | https://github.com/Richielee630/TMMA       |    23 |      34 | 8 months ago | <2025-11-12 Wed> |
| LoopLynx     | https://github.com/zjnyly/LoopLynx         |     1 |       8 | 3 weeks ago  | <2025-11-12 Wed> |
| HLSTransform | https://github.com/HLSTransform/submission |   111 |       4 | last year    | <2025-11-12 Wed> |
| allo         | https://github.com/cornell-zhang/allo      |   296 |     369 | 2 days ago   | <2025-11-12 Wed> |
| Torch-MLIR   | https://github.com/llvm/torch-mlir         |  1700 |    3531 | 20 hours ago | <2025-11-26 Wed> |
| CIRCT        | https://github.com/llvm/circt              |  2000 |   10580 | 12 hours ago | <2025-11-26 Wed> |
| PandA-bambu  | https://github.com/ferrandi/PandA-bambu    |   296 |    6300 | 6 months ago | <2025-11-27 Thu> |

* Deepwok/MASE: elaboration attempt + blockage
** Steps run
#+begin_src bash
git clone git@github.com:RCoeurjoly/mase.git
cd mase
git checkout RCoeurjoly/flake

# Dev env (works, not fully polished)
nix develop
source .venv/bin/activate

# Generate RTL via MASE helper
python LLM2FPGA.py

# Check outputs
ls ~/.mase

# Build yosys-slang (per its README), ensure yosys in PATH
cd ~/yosys-slang

# Elaborate with slang (SystemVerilog)
yosys -m build/slang.so -p \
  "read_slang \
     /home/roland/mase/src/mase_components/memory/rtl/fifo.sv \
     /home/roland/mase/src/mase_components/common/rtl/mux.sv \
     /home/roland/.mase/top/hardware/rtl/*.sv \
     /home/roland/mase/src/mase_components/common/rtl/single_element_repeat.sv \
     /home/roland/mase/src/mase_components/common/rtl/unpacked_register_slice.sv \
     /home/roland/mase/src/mase_components/cast/rtl/fixed_rounding.sv \
     /home/roland/mase/src/mase_components/memory/rtl/input_buffer.sv \
     /home/roland/mase/src/mase_components/memory/rtl/unpacked_skid_buffer.sv \
     /home/roland/mase/src/mase_components/cast/rtl/fixed_round.sv \
     /home/roland/mase/src/mase_components/cast/rtl/fixed_signed_cast.sv \
     /home/roland/mase/src/mase_components/cast/rtl/signed_clamp.sv \
     /home/roland/mase/src/mase_components/cast/rtl/floor_round.sv \
     /home/roland/mase/src/mase_components/memory/rtl/blk_mem_gen_0.sv \
     /home/roland/mase/src/mase_components/memory/rtl/simple_dual_port_ram.sv \
     --top top"
#+end_src

** Output
 /----------------------------------------------------------------------------\
 |  yosys -- Yosys Open SYnthesis Suite                                       |
 |  Copyright (C) 2012 - 2024  Claire Xenia Wolf <claire@yosyshq.com>         |
 |  Distributed under an ISC-like license, type "license" to see terms        |
 \----------------------------------------------------------------------------/
 Yosys 0.45+126 (git sha1 80119386c, g++ 11.4.0-1ubuntu1~22.04 -Og -fPIC)

-- Running command `read_slang /home/roland/mase/src/mase_components/memory/rtl/fifo.sv /home/roland/mase/src/mase_components/common/rtl/mux.sv /home/roland/.mase/top/hardware/rtl/*.sv /home/roland/mase/src/mase_components/common/rtl/single_element_repeat.sv /home/roland/mase/src/mase_components/common/rtl/unpacked_register_slice.sv /home/roland/mase/src/mase_components/cast/rtl/fixed_rounding.sv /home/roland/mase/src/mase_components/memory/rtl/input_buffer.sv /home/roland/mase/src/mase_components/memory/rtl/unpacked_skid_buffer.sv /home/roland/mase/src/mase_components/cast/rtl/fixed_round.sv /home/roland/mase/src/mase_components/cast/rtl/fixed_signed_cast.sv /home/roland/mase/src/mase_components/cast/rtl/signed_clamp.sv /home/roland/mase/src/mase_components/cast/rtl/floor_round.sv /home/roland/mase/src/mase_components/memory/rtl/blk_mem_gen_0.sv /home/roland/mase/src/mase_components/memory/rtl/simple_dual_port_ram.sv --top top' --

1. Executing SLANG frontend.
Top level design units:
    top

../.mase/top/hardware/rtl/top.sv:182:1: error: unknown module 'net_0_bias_source'
net_0_bias_source #(
^~~~~~~~~~~~~~~~~
../.mase/top/hardware/rtl/top.sv:264:1: error: unknown module 'net_2_weight_source'
net_2_weight_source #(
^~~~~~~~~~~~~~~~~~~
../.mase/top/hardware/rtl/top.sv:278:1: error: unknown module 'net_2_bias_source'
net_2_bias_source #(
^~~~~~~~~~~~~~~~~
../.mase/top/hardware/rtl/matrix_stream_transpose.sv:43:17: warning: finish argument must have value of 0, 1, or 2 [-Wfinish-num]
    else $fatal("DIM0 compute is not divisible!");
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
../.mase/top/hardware/rtl/matrix_stream_transpose.sv:45:17: warning: finish argument must have value of 0, 1, or 2 [-Wfinish-num]
    else $fatal("DIM1 compute is not divisible!");
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
../.mase/top/hardware/rtl/matmul.sv:84:17: warning: finish argument must have value of 0, 1, or 2 [-Wfinish-num]
    else $fatal("A_TOTAL_DIM0 must equal B_TOTAL_DIM1!");
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
../.mase/top/hardware/rtl/matmul.sv:86:17: warning: finish argument must have value of 0, 1, or 2 [-Wfinish-num]
    else $fatal("A_COMPUTE_DIM0 must equal B_COMPUTE_DIM1!");
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
../.mase/top/hardware/rtl/matmul.sv:90:17: warning: finish argument must have value of 0, 1, or 2 [-Wfinish-num]
    else $fatal("A_DIM0 compute is not divisible!");
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
../.mase/top/hardware/rtl/matmul.sv:92:17: warning: finish argument must have value of 0, 1, or 2 [-Wfinish-num]
    else $fatal("A_DIM1 compute is not divisible!");
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
../.mase/top/hardware/rtl/matmul.sv:94:17: warning: finish argument must have value of 0, 1, or 2 [-Wfinish-num]
    else $fatal("B_DIM0 compute is not divisible!");
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
../.mase/top/hardware/rtl/matmul.sv:96:17: warning: finish argument must have value of 0, 1, or 2 [-Wfinish-num]
    else $fatal("B_DIM1 compute is not divisible!");
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
../.mase/top/hardware/rtl/simple_matmul.sv:64:19: warning: finish argument must have value of 0, 1, or 2 [-Wfinish-num]
      else $fatal("OUT_WIDTH must be %d if OUTPUT_ROUNDING == 0", ACC_WIDTH);
                  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
../.mase/top/hardware/rtl/simple_matmul.sv:66:19: warning: finish argument must have value of 0, 1, or 2 [-Wfinish-num]
      else $fatal("OUT_FRAC_WIDTH must be %d if OUTPUT_ROUNDING == 0", ACC_FRAC_WIDTH);
                  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Build failed: 3 errors, 10 warnings
ERROR: Compilation failed

** Output (summary)
- Yosys: 0.45+126 (80119386c)
- Frontend: slang (SystemVerilog)
- Errors (3): unknown module instances required by top:
  - net_0_bias_source
  - net_2_weight_source
  - net_2_bias_source
- Warnings (10): `$fatal` form (“finish argument must be 0/1/2”) — non-blocking for 1b.

** Conclusion
- Status: partially compatible.
- We can generate SystemVerilog from MASE, but Yosys+slang elaboration fails because some net_*_source modules are not generated by LLM2FPGA.py (design incomplete).
- This is a generator issue, not a limitation of Yosys or slang.
* LoopLynx
They point to https://github.com/zjnyly/TeraFly, with requires the following proprietary tools:
- XRT	2023.2
- Vitis HLS & Vivado	2023.2
** Conclusion
- Status: incompatible with the LLM2FPGA constraints.
- The published flow depends on AMD/Xilinx proprietary tooling (XRT, Vitis HLS, Vivado 2023.2).
- Reaching Yosys from this codebase would require re-implementing the hardware or replacing the entire vendor toolchain, which is outside the scope of LLM2FPGA.
* HLSTransform
Of the four prerequisites (https://github.com/HLSTransform/submission?tab=readme-ov-file#prerequisites), three are contrary to the goals of LLM2FPGA.

1. EC2 instance (z1d.2xlarge recommended), 2. AWS FPGA Developer AMI (install) and 3. S3 Bucket would lock us in a cloud environment, contrary to our purpose of local inference.
** Conclusion
- Status: incompatible with the LLM2FPGA constraints.
- The reference flow requires AWS EC2, the AWS FPGA Developer AMI and S3, which contradicts the project goal of local, open-source inference without cloud lock-in.
- No attempt was made to reproduce their cloud-based flow; instead, the incompatibility is at the environment/tooling level.
* allo
Allo has 4 backends:
- LLVM (CPU)
- AMD Vitis HLS (FPGA)
- RapidStream TAPA (FPGA)
  - Requires Vitis HLS (https://github.com/rapidstream-org/rapidstream-tapa?tab=readme-ov-file#prerequisites)
- Multi-Threaded Simulator (CPU)
- AMD MLIR-AIE (AI Engine)
  - Targets AMD AI Engine-enabled devices, not FPGAs (https://github.com/Xilinx/mlir-aie/tree/main?tab=readme-ov-file)
* TMMA
https://github.com/Richielee630/TMMA/tree/main?tab=readme-ov-file#-ongoing-research--work-in-progress

The accelerator resides in the git submodule https://github.com/Richielee630/MatMul_SA

It requires Vitis HSL to compile:

https://github.com/Richielee630/MatMul_SA?tab=readme-ov-file#example

Vitis HSL is freeware, not open source
https://www.xilinx.com/support/download/index.html/content/xilinx/en/downloadNav/vivado-design-tools.html

https://adaptivesupport.amd.com/s/article/Xilinx-Licensing-Solution-Center?language=en_US

There are open source HLS tools:
https://github.com/ymherklotz/vericert, but the headers in MatMul_SA are vitis specific

https://github.com/Richielee630/MatMul_SA/blob/main/mmult_accel.cpp#L1

We try elaboration with panda bambu.

My work resides on the fork: https://github.com/RCoeurjoly/MatMul_SA

** panda bambu

../PandA-bambu/bambu.AppImage --generate-interface=INFER mmult_accel.cpp --top-fname=mmult_accel
 ==  Bambu executed with: /tmp/.mount_bambu.hm7Z7N/usr/bin/bambu --generate-interface=INFER --top-fname=mmult_accel mmult_accel.cpp


********************************************************************************
                    ____                  _
                   | __ )  __ _ _ __ ___ | |_   _   _
                   |  _ \ / _` | '_ ` _ \| '_ \| | | |
                   | |_) | (_| | | | | | | |_) | |_| |
                   |____/ \__,_|_| |_| |_|_.__/ \__,_|

********************************************************************************
                         High-Level Synthesis Tool

                         Politecnico di Milano - DEIB
                          System Architectures Group
********************************************************************************
                Copyright (C) 2004-2024 Politecnico di Milano
 Version: PandA 2024.10 - Revision c2ba6936ca2ed63137095fea0b630a1c66e20e63-main

  Analyzing function mmult_accel
    Parameter @428529 A
    Interface specification:
      Parameter : A
      Protocol  : m_axi
      Direction : IN
      Bundle    : gmemA
      Bitwidth  : 8
      Alignment : 1
    Parameter @428530 B
    Interface specification:
      Parameter : B
      Protocol  : m_axi
      Direction : IN
      Bundle    : gmemB
      Bitwidth  : 8
      Alignment : 1
    Parameter @428531 C
    Interface specification:
      Parameter : C
      Protocol  : m_axi
      Direction : OUT
      Bundle    : gmemC
      Bitwidth  : 32
      Alignment : 4
    Parameter @428532 N
    Interface specification:
      Parameter : N
      Protocol  : default
      Direction : IN
      Bundle    : N
      Bitwidth  : 32
      Alignment : 4
    Parameter @428533 K
    Interface specification:
      Parameter : K
      Protocol  : default
      Direction : IN
      Bundle    : K
      Bitwidth  : 32
      Alignment : 4
    Parameter @428534 M
    Interface specification:
      Parameter : M
      Protocol  : default
      Direction : IN
      Bundle    : M
      Bitwidth  : 32
      Alignment : 4
    Parameter @428535 update_A
    Interface specification:
      Parameter : update_A
      Protocol  : default
      Direction : IN
      Bundle    : update_A
      Bitwidth  : 32
      Alignment : 4
  Analyzed function mmult_accel
Required never inline for function mmult_accel

  Functions to be synthesized:
    mmult_accel


  Memory allocation information:
    BRAM bitsize: 32
    Spec may not exploit DATA bus width
    All the data have a known address
    Internal data is not externally accessible
    DATA bus bitsize: 32
    ADDRESS bus bitsize: 19
    SIZE bus bitsize: 6
    Code has LOADs or STOREs with unaligned accesses
    Internally allocated memory (no private memories): 0
    Internally allocated memory: 251904
  Time to perform memory allocation: 0.00 seconds


  Memory allocation information:
    BRAM bitsize: 32
    Spec may not exploit DATA bus width
    All the data have a known address
    Internal data is not externally accessible
    DATA bus bitsize: 32
    ADDRESS bus bitsize: 19
    SIZE bus bitsize: 6
    Code has LOADs or STOREs with unaligned accesses
    Internally allocated memory (no private memories): 0
    Internally allocated memory: 251904
  Time to perform memory allocation: 0.00 seconds


  Module allocation information for function mmult_accel:
    Number of complex operations: 74
    Number of complex operations: 74
  Time to perform module allocation: 0.12 seconds


  Scheduling Information of function mmult_accel:
    Number of control steps: 82
    Minimum slack: 0.80968266266663957
    Estimated max frequency (MHz): 108.81017088906721
  Time to perform scheduling: 0.11 seconds


  State Transition Graph Information of function mmult_accel:
    Number of states: 96
    Done port is registered
  Time to perform creation of STG: 0.01 seconds


  Easy binding information for function mmult_accel:
    Bound operations:832/1191
  Time to perform easy binding: 0.00 seconds


  Storage Value Information of function mmult_accel:
    Number of storage values inserted: 247
  Time to compute storage value information: 0.00 seconds

  Slack computed in 0.02 seconds
  Weight computation completed in 0.02 seconds
  False-loop computation completed in 0.00 seconds

  Register binding information for function mmult_accel:
    Register allocation algorithm obtains a sub-optimal result: 220 registers(LB:66)
  Time to perform register binding: 0.02 seconds

  Clique covering computation completed in 0.04 seconds

  Module binding information for function mmult_accel:
    Number of modules instantiated: 1130
    Number of performance conflicts: 104
    Estimated resources area (no Muxes and address logic): 7479
    Estimated area of MUX21: 974
    Total estimated area: 8453
    Estimated number of DSPs: 9
  Time to perform module binding: 0.09 seconds


  Register binding information for function mmult_accel:
    Register allocation algorithm obtains a sub-optimal result: 220 registers(LB:66)
  Time to perform register binding: 0.02 seconds


  Connection Binding Information for function mmult_accel:
    Number of allocated multiplexers (2-to-1 equivalent): 100
  Time to perform interconnection binding: 0.02 seconds

  Total number of flip-flops in function mmult_accel: 4116

# We check the return code
  echo $?
0

This results in the following files being created:

        HLS_output/
        array_ref_428617.mem
        array_ref_429690.mem
        array_ref_429915.mem
        array_ref_430001.mem
        array_ref_430034.mem
        mmult_accel.v
        synthesize_Synthesis_mmult_accel.sh

We have to copy some memories that were not created by bambu:
cp array_ref_428617.mem array.mem
cp array_ref_428617.mem array_a.mem
	
We elaborate with yosys, which succedds:

yosys -s mmult_accel.ys | tee yosys_mmult_accel.log
	
   Number of wires:             2828241
   Number of wire bits:         14045295
   Number of public wires:      256645
   Number of public wire bits:  2102595
   Number of ports:               5644
   Number of port bits:          57744
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:             2657876
     $add                          132
     $adff                           1
     $and                       999063
     $dff                           27
     $dffe                      249035
     $eq                           113
     $gt                             1
     $le                            21
     $logic_and                     48
     $logic_not                      3
     $logic_or                      16
     $lt                            16
     $mul                            5
     $mux                       1160007
     $ne                             1
     $neg                            1
     $not                          131
     $or                            19
     $pmux                          27
     $reduce_bool               248841
     $reduce_or                     48
     $sdff                          25
     $sdffe                          9
     $shl                           58
     $shr                          221
     $sshr                           2
     $sub                            5

Warnings: 8 unique messages, 9 total
End of script. Logfile hash: ab55b8b8cc, CPU: user 1593.26s system 41.77s, MEM: 13967.27 MB peak
Yosys 0.45+126 (git sha1 80119386c, g++ 11.4.0-1ubuntu1~22.04 -Og -fPIC)
Time spent: 26% 7x opt_muxtree (419 sec), 26% 7x opt_dff (419 sec), 20% 9x opt_clean (316 sec), ...
** Conclusion
- Status: compatible at kernel level via open-source HLS.
- The Vitis-HLS-based kernel mmult_accel.cpp can be synthesized with PandA-bambu (2024.10) to Verilog (mmult_accel.v) using the command:

  #+begin_src bash
  ../PandA-bambu/bambu.AppImage --generate-interface=INFER mmult_accel.cpp --top-fname=mmult_accel
  #+end_src

- Yosys 0.45 can parse and elaborate mmult_accel.v, after providing the expected *.mem files (array.mem, array_a.mem). The resulting netlist is large but valid:

  - ~2.8M wires, ~14M wire bits.
  - ~2.7M cells (≈1.16M $mux, ≈1.0M $and, ≈249k $dffe, etc.).
  - No $mem cells (Bambu emitted only flop-based logic, no inferred RAMs).

- This demonstrates that an open-source HLS path (PandA-bambu -> Verilog -> Yosys) exists for TMMA’s core accelerator, without relying on Vitis HLS.

* Torch-MLIR + CIRCT
The compatibility check lives here: https://github.com/RCoeurjoly/hot-chips-2022-pytorch-circt-hls-demo

To run it reproducibly, you have to install 2 tools:

- Torch-MLIR https://github.com/llvm/torch-mlir?tab=readme-ov-file#install-torch-mlir-snapshot: I followed virtual environment route.
- CIRCT: https://github.com/dtzSiFive/circt-nix, just do nix build

I achieved a PyTorch to SystemVerilog pipeline, and the SystemVerilog was processed successfully with yosys-slang.

The pipeline had to be updated with respect to upstream (https://github.com/mikeurbach/hot-chips-2022-pytorch-circt-hls-demo) because the tools it used were outdated: 

- CIRCT-HLS (https://github.com/circt-hls/circt-hls) is no longer maintained and the developers recomend using CIRCT directly.
- Polygeist (https://github.com/llvm/Polygeist) has not been maintained for a year.

The pipeline (https://github.com/RCoeurjoly/hot-chips-2022-pytorch-circt-hls-demo/blob/main/my-demo.sh) consists of successive lowering from PyTorch to SystemVerilog.

I have also attempted to lower GPT2, a 120M (124439808) parameter model.

Torch-MLIR successfully lowers GPT2 to MLIR, but more work is needed for lowering to SystemVerilog, mainly choosing the right transforms/passes.

** Conclusion
- Status: compatible (for small kernels), scalable WIP.
- A PyTorch -> MLIR -> SystemVerilog pipeline exists (in my fork) and the generated SV elaborates successfully with yosys-slang for the demo kernels.
- Torch-MLIR can lower GPT-2 (120M parameters) to MLIR, but the CIRCT lowering to SystemVerilog is not yet complete; more work is needed on the pass pipeline.
